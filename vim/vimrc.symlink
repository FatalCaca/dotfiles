let mapleader = ","
let maplocalleader = "à"

" Vundle {

set nocompatible              " be iMproved, required
filetype off                  " required

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" alternatively, pass a path where Vundle should install plugins
"call vundle#begin('~/some/path/here')

" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'

Plugin 'kien/ctrlp.vim'
Plugin 'Shougo/neocomplete.vim'
Plugin 'spf13/PIV'
Plugin 'Shougo/neosnippet'
Plugin 'Shougo/neosnippet-snippets'
Plugin 'Konfekt/FastFold'
Plugin 'othree/xml.vim'
Plugin 'Townk/vim-autoclose'
Plugin 'shawncplus/phpcomplete.vim'

" All of your Plugins must be added before the following line
call vundle#end()            " required
filetype plugin indent on    " required

" }

" Caca {

    set background=dark
    filetype plugin indent on   " Automatically detect file types.
    syntax on                   " Syntax highlighting
    set mouse=a                 " Automatically enable mouse usage
    set mousehide               " Hide the mouse cursor while typing
    scriptencoding utf-8

    if has('clipboard')
        if has('unnamedplus')  " When possible use + register for copy-paste
            set clipboard=unnamed,unnamedplus
        else         " On mac and Windows, use * register for copy-paste
            set clipboard=unnamed
        endif
    endif

    set history=1000                    " Store a ton of history (default is 20)
    set hidden                          " Allow buffer switching without saving
    set iskeyword-=.                    " '.' is an end of word designator
    set iskeyword-=#                    " '#' is an end of word designator
    set iskeyword-=-                    " '-' is an end of word designator

    " Setting up the directories {
        set backup                  " Backups are nice ...
        if has('persistent_undo')
            set undofile                " So is persistent undo ...
            set undolevels=1000         " Maximum number of changes that can be undone
            set undoreload=10000        " Maximum number lines to save for undo on a buffer reload
        endif

        " To disable views add the following to your .vimrc.before.local file:
        "   let g:spf13_no_views = 1
        if !exists('g:spf13_no_views')
            " Add exclusions to mkview and loadview
            " eg: *.*, svn-commit.tmp
            let g:skipview_files = [
                \ '\[example pattern\]'
                \ ]
        endif
    " }

    " Vim UI {

        color monokai
        set tabpagemax=15               " Only show 15 tabs
        set showmode                    " Display the current mode
        set cursorline                  " Highlight current line

        highlight clear SignColumn      " SignColumn should match background
        highlight clear LineNr          " Current line number row will have same background color in relative mode

        if has('cmdline_info')
            set ruler                   " Show the ruler
            set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " A ruler on steroids
            set showcmd                 " Show partial commands in status line and
                                        " Selected characters/lines in visual mode
        endif

        if has('statusline')
            set laststatus=2

            " Broken down into easily includeable segments
            set statusline=%<%f\                     " Filename
            set statusline+=%w%h%m%r                 " Options
            set statusline+=\ [%{&ff}/%Y]            " Filetype
            set statusline+=\ [%{getcwd()}]          " Current dir
            set statusline+=%=%-14.(%l,%c%V%)\ %p%%  " Right aligned file nav info
        endif

        set backspace=indent,eol,start  " Backspace for dummies
        set linespace=0                 " No extra spaces between rows
        set number                      " Line numbers on
        set showmatch                   " Show matching brackets/parenthesis
        set incsearch                   " Find as you type search
        set hlsearch                    " Highlight search terms
        set winminheight=0              " Windows can be 0 line high
        set ignorecase                  " Case insensitive search
        set smartcase                   " Case sensitive when uc present
        set wildmenu                    " Show list instead of just completing
        set wildmode=list:longest,full  " Command <Tab> completion, list matches, then longest common part, then all.
        set whichwrap=b,s,h,l,<,>,[,]   " Backspace and cursor keys wrap too
        set scrolljump=5                " Lines to scroll when cursor leaves screen
        set scrolloff=3                 " Minimum lines to keep above and below cursor
        set list
        set listchars=tab:›\ ,trail:•,extends:#,nbsp:. " Highlight problematic whitespace

    " }

    " Formatting {

        set nowrap                      " Do not wrap long lines
        set autoindent                  " Indent at the same level of the previous line
        set shiftwidth=4                " Use indents of 4 spaces
        set expandtab                   " Tabs are spaces, not tabs
        set tabstop=4                   " An indentation every four columns
        set softtabstop=4               " Let backspace delete indent
        set nojoinspaces                " Prevents inserting two spaces after punctuation on a join (J)
        set splitright                  " Puts new vsplit windows to the right of the current
        set splitbelow                  " Puts new split windows to the bottom of the current
        set matchpairs+=<:>             " Match, to be used with %
        set pastetoggle=<F12>           " pastetoggle (sane indentation on pastes)

        " Remove trailing whitespaces and ^M chars
        " To disable the stripping of whitespace, add the following to your
        " .vimrc.before.local file:
        "   let g:spf13_keep_trailing_whitespace = 1
        "autocmd FileType c,cpp,java,go,php,javascript,puppet,python,rust,twig,xml,yml,perl,sql autocmd BufWritePre <buffer> if !exists('g:spf13_keep_trailing_whitespace') | call StripTrailingWhitespace() | endif
        "autocmd FileType go autocmd BufWritePre <buffer> Fmt
        autocmd BufNewFile,BufRead *.html.twig set filetype=html.twig
        autocmd FileType haskell,puppet,ruby,yml setlocal expandtab shiftwidth=2 softtabstop=2
        " preceding line best in a plugin but here for now.

        autocmd BufNewFile,BufRead *.coffee set filetype=coffee

    " }

    " Visual shifting (does not exit Visual mode)
    vnoremap < <gv
    vnoremap > >gv

    " Allow using the repeat operator with a visual selection (!)
    " http://stackoverflow.com/a/8064607/127816
    vnoremap . :normal .<CR>

    " For when you forget to sudo.. Really Write the file.
    cmap w!! w !sudo tee % >/dev/null


    " NeoComplete {
        " Disable AutoComplPop.
        let g:acp_enableAtStartup = 0
        " Use neocomplete.
        let g:neocomplete#enable_at_startup = 1
        " Use smartcase.
        let g:neocomplete#enable_smart_case = 1
        " Set minimum syntax keyword length.
        " let g:neocomplete#sources#syntax#min_keyword_length = 2
        let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

        " Define dictionary.
        let g:neocomplete#sources#dictionary#dictionaries = {
            \ 'default' : '',
            \ 'vimshell' : $HOME.'/.vimshell_hist',
            \ 'scheme' : $HOME.'/.gosh_completions'
                \ }

        " Define keyword.
        if !exists('g:neocomplete#keyword_patterns')
            let g:neocomplete#keyword_patterns = {}
        endif
        let g:neocomplete#keyword_patterns['default'] = '\h\w*'

        " Plugin key-mappings.
        inoremap <expr><C-g>     neocomplete#undo_completion()
        inoremap <expr><C-l>     neocomplete#complete_common_string()

        " Recommended key-mappings.
        " <CR>: close popup and save indent.
        "inoremap <silent> <TAB> <C-r>=<SID>my_cr_function()<CR>
        "function! s:my_cr_function()
          "return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
          " For no inserting <CR> key.
          "return pumvisible() ? "\<C-y><TAB>" : "\<TAB>"
        "endfunction
        " <TAB>: completion.
        inoremap <expr><s-tab>  pumvisible() ? "\<C-y>" : "\<Space>"
        " <C-h>, <BS>: close popup and delete backword char.
        inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
        inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
        " Close popup by <Space>.
        "inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

        " AutoComplPop like behavior.
        let g:neocomplete#enable_auto_select = 1

        " Enable omni completion.
        autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
        autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
        autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
        autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
        autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

        " Enable heavy omni completion.
        if !exists('g:neocomplete#sources#omni#input_patterns')
          let g:neocomplete#sources#omni#input_patterns = {}
        endif
        "let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
        "let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
        "let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

        " For perlomni.vim setting.
        " https://github.com/c9s/perlomni.vim
        let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
    " }

    " NeoSnippet {

        " Plugin key-mappings.
        imap <C-t>     <Plug>(neosnippet_expand_or_jump)
        smap <C-t>     <Plug>(neosnippet_expand_or_jump)
        xmap <C-t>     <Plug>(neosnippet_expand_target)

        " SuperTab like snippets behavior.
        "imap <expr><TAB>
        " \ pumvisible() ? "\<C-n>" :
        " \ neosnippet#expandable_or_jumpable() ?
        " \    "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
        imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
        \ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

        " For conceal markers.
        if has('conceal')
          set conceallevel=2 concealcursor=niv
        endif

        let g:neosnippet#snippets_directory='~/.dotfiles/vim/snippets'

    " }

    " ctrlp {
        let g:ctrlp_custom_ignore = {
          \ 'dir':  'vendor',
          \ }
    " }

    nnoremap S <C-]>

    nnoremap t j
    nnoremap s k
    vnoremap t j
    vnoremap s k

    nnoremap é w
    nnoremap É W
    nnoremap dé dw
    nnoremap yé yw
    nnoremap cé cw
    nnoremap caé caw
    nnoremap cié cis
    nnoremap daé daw
    nnoremap dié dis
    nnoremap yaé yaw
    nnoremap yié yis
    nnoremap É caw

    " To erase word with current yank
    nnoremap <leader>p viwp<esc>byw

    nnoremap $ *
    nnoremap * $

    inoremap <c-U> <esc>viwUea
    nnoremap <c-U> <esc>bveUel

    nnoremap <leader>ev :vsplit ~/.dotfiles/vim/vimrc.symlink<cr>
    nnoremap <leader>es :vsplit ~/.dotfiles/vim/snippets/php.snip<cr>
    nnoremap <leader>ets :vsplit ~/.dotfiles/vim/snippets/twig.snip<cr>
    nnoremap <leader>sv :source ~/.dotfiles/vim/vimrc.symlink<cr>

    iabbrev @@ simon.ballu@gmail.com


    nnoremap <leader>" viw<esc>a"<esc>hbi"<esc>lel
    nnoremap <leader>' viw<esc>a'<esc>hbi'<esc>lel

    autocmd FileType javascript nnoremap <buffer> <leader>c I//<esc>
    autocmd FileType python     nnoremap <buffer> <leader>c I#<esc>

    onoremap p i(
    onoremap ib i(

    onoremap lp :<c-u>normal! F)vi(<cr>
    onoremap np :<c-u>normal! f(vi)<cr>
    onoremap lb :<c-u>normal! F]vi[<cr>
    onoremap nb :<c-u>normal! f[vi]<cr>
    onoremap lc :<c-u>normal! F}vi{<cr>
    onoremap nc :<c-u>normal! f{vi}<cr>
    onoremap l' :<c-u>normal! F'vi'<cr>
    onoremap n' :<c-u>normal! f'vi'<cr>

    nnoremap T i<cr><esc>

    nnoremap ( F(
    nnoremap ) f)
    nnoremap { F{
    nnoremap } f}
    nnoremap [ F[
    nnoremap ] f]

    nnoremap E <c-]>

    nnoremap S f<
    nnoremap R f>

    inoremap lkj <esc>
    inoremap gq <esc>

    nnoremap + %

    nnoremap Y y$

    set nobackup
    set noswapfile
    set pastetoggle=F12

    au WinEnter * set nofen
    au WinLeave * set nofen

    set nofoldenable
    set foldmethod=manual
    set tags=./tags;/home/simon/Dropbox/codingZ/php/game/
    set wildmenu
    set wildmode=list:longest,full
    set scrolljump=5
    set scrolloff=3

    inoremap <c-r> <Plug>(snipMateNextOrTrigger)
    let g:spf13_no_omni_complete = 1

" }

